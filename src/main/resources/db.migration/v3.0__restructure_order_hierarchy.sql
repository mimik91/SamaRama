-- V3.0__restructure_order_hierarchy.sql
-- Przebudowa hierarchii: TransportOrder jako baza, ServiceOrder jako rozszerzenie

-- 1. Tworzenie nowej tabeli transport_orders jako tabeli bazowej
CREATE TABLE transport_orders_new (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY,

    -- === PODSTAWOWE INFORMACJE O ZAMÓWIENIU ===
    bicycle_id BIGINT NOT NULL,
    client_id BIGINT NOT NULL,

    -- === INFORMACJE O ODBIORZE ===
    pickup_date DATE NOT NULL,
    pickup_address VARCHAR(255) NOT NULL,
    pickup_latitude DECIMAL(10,8),
    pickup_longitude DECIMAL(11,8),
    pickup_time_from TIME,
    pickup_time_to TIME,

    -- === INFORMACJE O DOSTAWIE ===
    delivery_address VARCHAR(255) NOT NULL,
    delivery_latitude DECIMAL(10,8),
    delivery_longitude DECIMAL(11,8),
    target_service_id BIGINT NOT NULL,

    -- === STATUS I DATY ===
    status VARCHAR(20) NOT NULL DEFAULT 'PENDING',
    order_date TIMESTAMP NOT NULL DEFAULT NOW(),

    -- === CENY ===
    transport_price DECIMAL(10,2) NOT NULL,

    -- === TRANSPORT DETAILS ===
    estimated_time INTEGER, -- w minutach
    actual_pickup_time TIMESTAMP,
    actual_delivery_time TIMESTAMP,

    -- === NOTATKI ===
    transport_notes VARCHAR(500),
    additional_notes VARCHAR(500),

    -- === METADANE ===
    last_modified_by VARCHAR(100),
    last_modified_date TIMESTAMP,

    PRIMARY KEY (id),
    FOREIGN KEY (bicycle_id) REFERENCES incomplete_bikes(id),
    FOREIGN KEY (client_id) REFERENCES incomplete_users(id),
    FOREIGN KEY (target_service_id) REFERENCES bike_services(id)
);

-- 2. Modyfikacja tabeli service_orders (będzie dziedziczyć po transport_orders_new)
-- Najpierw backup
CREATE TABLE service_orders_backup AS SELECT * FROM service_orders;

-- Tworzenie nowej tabeli service_orders
CREATE TABLE service_orders_new (
    id BIGINT NOT NULL,

    -- === INFORMACJE O SERWISIE ===
    service_package_id BIGINT,
    service_package_code VARCHAR(20),
    service_price DECIMAL(10,2),
    service_notes VARCHAR(500),

    -- === DATY SERWISU ===
    service_start_date TIMESTAMP,
    service_completion_date TIMESTAMP,

    PRIMARY KEY (id),
    FOREIGN KEY (id) REFERENCES transport_orders_new(id) ON DELETE CASCADE,
    FOREIGN KEY (service_package_id) REFERENCES service_packages(id)
);

-- 3. Dodanie check constraints dla statusów
ALTER TABLE transport_orders_new
    ADD CONSTRAINT chk_transport_order_status
    CHECK (status IN ('PENDING', 'CONFIRMED', 'PICKED_UP', 'IN_SERVICE', 'ON_THE_WAY_BACK', 'CANCELLED'));

-- 4. Migracja danych z service_orders do nowej struktury
INSERT INTO transport_orders_new (
    bicycle_id, client_id, pickup_date, pickup_address,
    pickup_latitude, pickup_longitude, delivery_address,
    target_service_id, status, order_date, transport_price,
    additional_notes, last_modified_by, last_modified_date
)
SELECT
    so.bicycle_id,
    so.user_id,
    so.pickup_date,
    so.pickup_address,
    so.pickup_latitude,
    so.pickup_longitude,
    'SERWIS WŁASNY' as delivery_address, -- dla zamówień serwisowych
    1 as target_service_id, -- domyślny własny serwis
    so.status,
    so.orderdate,
    so.price as transport_price,
    so.additional_notes,
    so.last_modified_by,
    so.last_modified_date
FROM service_orders so;

-- 5. Migracja danych serwisowych do service_orders_new
INSERT INTO service_orders_new (
    id, service_package_id, service_package_code, service_price, service_notes
)
SELECT
    to_new.id,
    so.service_package_id,
    so.service_package_code,
    so.price as service_price,
    so.service_notes
FROM transport_orders_new to_new
JOIN service_orders so ON so.bicycle_id = to_new.bicycle_id
    AND so.pickup_date = to_new.pickup_date;

-- 6. Dodanie indeksów
CREATE INDEX idx_transport_orders_client ON transport_orders_new(client_id);
CREATE INDEX idx_transport_orders_bicycle ON transport_orders_new(bicycle_id);
CREATE INDEX idx_transport_orders_pickup_date ON transport_orders_new(pickup_date);
CREATE INDEX idx_transport_orders_status ON transport_orders_new(status);
CREATE INDEX idx_transport_orders_target_service ON transport_orders_new(target_service_id);

CREATE INDEX idx_service_orders_package ON service_orders_new(service_package_id);
CREATE INDEX idx_service_orders_package_code ON service_orders_new(service_package_code);

-- 7. Dodanie komentarzy
COMMENT ON TABLE transport_orders_new IS 'Bazowa tabela dla wszystkich zamówień transportu rowerów';
COMMENT ON TABLE service_orders_new IS 'Rozszerzenie zamówień transportowych o usługi serwisowe';

COMMENT ON COLUMN transport_orders_new.status IS 'Status zamówienia: PENDING, CONFIRMED, PICKED_UP, IN_SERVICE, ON_THE_WAY_BACK, CANCELLED';
COMMENT ON COLUMN transport_orders_new.target_service_id IS 'ID serwisu docelowego (może być serwis własny lub zewnętrzny)';
COMMENT ON COLUMN transport_orders_new.transport_price IS 'Cena transportu (dla service_orders to tylko transport, serwis w service_price)';

-- 8. Usuń stare tabele (po sprawdzeniu poprawności)
-- DROP TABLE service_orders;
-- DROP TABLE transport_orders;
-- DROP TABLE orders;

-- 9. Zmień nazwy tabel
-- ALTER TABLE transport_orders_new RENAME TO transport_orders;
-- ALTER TABLE service_orders_new RENAME TO service_orders;

-- 10. Aktualizacja sekwencji
SELECT setval('transport_orders_new_id_seq', (SELECT MAX(id) FROM transport_orders_new));

-- Sprawdzenie poprawności migracji
SELECT
    'transport_orders_new' as table_name, COUNT(*) as count FROM transport_orders_new
UNION ALL
SELECT
    'service_orders_new' as table_name, COUNT(*) as count FROM service_orders_new
UNION ALL
SELECT
    'service_orders_backup' as table_name, COUNT(*) as count FROM service_orders_backup;